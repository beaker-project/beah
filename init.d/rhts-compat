#!/bin/sh
# rhts:	Start the RHTS tests
#
# chkconfig: - 99 99
# description:  This service is used in rhts-compat mode.
#
# Tihs service should run after all other services are up, as it is running in
# foreground to get access to console just like original RHTS system used.

# Source function library.
. /etc/rc.d/init.d/functions

#Do NOT start rhts if the kernel command line has the following string: norhts
check4norhts() {
  grep -q norhts < /proc/cmdline
  if [ "$?" -eq 0 ] ; then
    echo -n $"The kernel command line contains norhts."
    echo -n $"Use empty 'RHTS_OPTION_COMPATIBLE' parameter or 'RhtsOptions: Compatible' in tasks metadata."
    # TODO: we still need a way how to temporarily disable beah.
    # Use similar principle.
  fi
}

prog=rhts-compat

if [ -f /etc/sysconfig/$prog ]; then
  . /etc/sysconfig/$prog
fi

# DO NOT CHANGE THESE VARIABLES WITHOUT GOOD REASON:

PIDFILE=$BEAH_ROOT/var/run/${prog}.pid
LOCKFILE=$BEAH_ROOT/var/lock/subsys/$prog

LAUNCHERS="$BEAH_ROOT/var/run/beah/rhts-compat/launchers"
KILLER="/mnt/testarea/rhts-compat-end"

function rhts_finish() {
  rhts-test-update $RESULT_SERVER $TESTID finish
  /bin/touch /var/cache/rhts/$TESTID/done
}

function rhts_error() {
  source /usr/bin/rhts_environment.sh
  report_result $TEST/compat Fail $1
  rhts_finish
}

export -f rhts_finish rhts_error

function rhts_compat_main() {
  local file=
  # el3,4,5 do not clean subdirectories on boot. el6 and fedora do.
  echo -n $"Performing /var/run/beah clean-up"
  # anything going to R/W into /var/run/beah should go through this!
  lockfile /var/run/beah.lock
    # remove files only if beah-rm.lock can be obtained:
    if lockfile -0 -r 0 /var/run/beah/rm.lock; then
      find /var/run/beah ! -type d -exec rm -f {} \;
    fi
  rm -f /var/run/beah.lock
  echo $"NOTE: This process runs in foreground."
  echo $"Use 'service $prog stop' from another terminal to stop it."
  echo $"It will not stop immediately but only after running tasks are processed."
  if [[ -f $KILLER ]]; then
    echo $"INFO: $prog: Removing existing kill file '$KILLER'."
    rm -f $KILLER
  fi
  if status; then
    echo $"INFO: $prog: service is running already."
    return 0
  fi
  echo $$ > $PIDFILE
  touch $LOCKFILE
  shopt -s nullglob
  while true; do
    if [[ -f $KILLER ]]; then
      echo $"INFO: $prog stopped."
      rm -f $KILLER
      break
    fi
    ls -1 $LAUNCHERS
    for file in $LAUNCHERS/*; do
      if [ -x $file ]; then
        $file
        rm -f $file
      fi
      if [[ -f $KILLER ]]; then
        echo $"INFO: $prog: stop scheduled."
        echo $"INFO: do 'rm -f $KILLER' to continue."
      fi
    done
    sleep 10
  done
  rm -f $LOCKFILE
  rm -f $PIDFILE
}

start() {
  echo $"Running RHTS-Compatibility Service..."
  check4norhts
  rhts_compat_main
}

wait_stop() {
  _stop || return 1
  while [[ -f $KILLER ]]; do
    sleep 60
  done
  echo " [OK]"
  echo $"Stopping $prog: All tasks finished."
}

stop () {
  _stop && echo " [OK]"
}

_stop() {
  if [[ -f $LOCKFILE ]]; then
    echo $"Stopping $prog: Service waiting for tasks to finish."
    echo -n $"Stopping $prog: "
    mkdir -p $(dirname $KILLER)
    touch $KILLER
    true
  else
    echo "$prog is not not running. [FAIL]"
    false
  fi
}

restart() {
  wait_stop
  start
}

condrestart(){
  [ -e $LOCKFILE ] && restart
  return 0
}

status() {
  if [ -e $PIDFILE ]; then
    local pid=`cat $PIDFILE`
    if [[ -z $pid ]]; then
      # not running, pidfile exists
      return 1
    elif ps -p $pid &> /dev/null; then
      if ps -wwo command -p $pid --no-headers | grep 'rhts-compat' >/dev/null; then
        if [ -e $KILLER ]; then
          # killer exists, will exit when tasks are done.
          return 3
        else
          # running
          return 0
        fi
      fi
    fi
    # not running, pidfile exists
    return 1
  elif [ -e $LOCKFILE ]; then
    # not running, lockfile exists
    return 2
  else
    # not running
    return 3
  fi
}

# See how we were called.
case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  status)
    #status $prog
    status
    RETVAL=$?
    ;;
  restart|force-reload)
    restart
    ;;
  condrestart|try-restart)
    condrestart
    ;;
  reload)
    ;;
  usage|*)
    echo $"Usage: $0 {start|stop|status|restart|condrestart|reload|force-reload|usage}"
    ;;
esac
exit $RETVAL

